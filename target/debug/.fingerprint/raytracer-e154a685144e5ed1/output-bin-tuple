{"message":"`main` function not found in crate `tuple`","code":{"code":"E0601","explanation":"No `main` function was found in a binary crate.\n\nTo fix this error, add a `main` function:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\nIf you don't know the basics of Rust, you can look at the\n[Rust Book][rust-book] to get started.\n\n[rust-book]: https://doc.rust-lang.org/book/\n"},"level":"error","spans":[{"file_name":"src\\bin\\tuple.rs","byte_start":2,"byte_end":10438,"line_start":2,"line_end":349,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"use std::ops::{Add, Div, Mul, Neg, Sub};","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//use crate::fuzzy_eq::*;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//Maybe PartialeEq","highlight_start":1,"highlight_end":19},{"text":"// could make pub x:","highlight_start":1,"highlight_end":21},{"text":"#[derive(Debug, Copy, Clone)]","highlight_start":1,"highlight_end":30},{"text":"pub struct Tuple {","highlight_start":1,"highlight_end":19},{"text":"   pub x: f64,","highlight_start":1,"highlight_end":15},{"text":"   pub y: f64,","highlight_start":1,"highlight_end":15},{"text":"   pub z: f64,","highlight_start":1,"highlight_end":15},{"text":"   pub w: f64,","highlight_start":1,"highlight_end":15},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Types of tuples","highlight_start":1,"highlight_end":19},{"text":"impl Tuple {","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // We create this so we can use Tuple::NEW ","highlight_start":1,"highlight_end":48},{"text":"    // What advantages does this give?","highlight_start":1,"highlight_end":39},{"text":"    pub fn new(x: f64, y: f64, z: f64, w: f64) -> Self {","highlight_start":1,"highlight_end":57},{"text":"            Tuple { x, y, z, w}","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn point(x: f64, y: f64, z: f64) -> Self {","highlight_start":1,"highlight_end":51},{"text":"            Tuple { x, y, z, w: 1.0}","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn vector(x: f64, y: f64, z: f64) -> Self {","highlight_start":1,"highlight_end":52},{"text":"            Tuple { x, y, z, w: 0.0}","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Could add check for point and vector.","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//impl Tuple{","highlight_start":1,"highlight_end":14},{"text":"//    pub fn point_check(&self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"//        self.w.fuzzy_eq(1.0)","highlight_start":1,"highlight_end":31},{"text":"//   }","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//    pub fn vector_check(&self) -> bool {","highlight_start":1,"highlight_end":43},{"text":"//        self.w.fuzzy_eq(0.0)","highlight_start":1,"highlight_end":31},{"text":"//    }","highlight_start":1,"highlight_end":8},{"text":"//}","highlight_start":1,"highlight_end":4},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Operations on tuples","highlight_start":1,"highlight_end":24},{"text":"// should i use: Add<Self>  ?????","highlight_start":1,"highlight_end":34},{"text":"impl Add for Tuple{","highlight_start":1,"highlight_end":20},{"text":"    type Output = Self;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn add(self, other: Tuple) -> Self::Output{","highlight_start":1,"highlight_end":48},{"text":"        Tuple::new( self.x + other.x,","highlight_start":1,"highlight_end":38},{"text":"                    self.y + other.y,","highlight_start":1,"highlight_end":38},{"text":"                    self.z + other.z,","highlight_start":1,"highlight_end":38},{"text":"                    self.w + other.w)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"   ","highlight_start":1,"highlight_end":4},{"text":"impl Sub for Tuple{","highlight_start":1,"highlight_end":20},{"text":"    type Output = Self;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn sub(self, other: Tuple) -> Self::Output{","highlight_start":1,"highlight_end":48},{"text":"        Tuple::new( self.x - other.x,","highlight_start":1,"highlight_end":38},{"text":"                    self.y - other.y,","highlight_start":1,"highlight_end":38},{"text":"                    self.z - other.z,","highlight_start":1,"highlight_end":38},{"text":"                    self.w - other.w)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":" // Create operator overload, to negate a tuple","highlight_start":1,"highlight_end":48},{"text":"impl Neg for Tuple{","highlight_start":1,"highlight_end":20},{"text":"    type Output = Self;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn neg(self) -> Self::Output {","highlight_start":1,"highlight_end":35},{"text":"        Self {x: -self.x, y: -self.y, z: -self.z, w: -self.w}","highlight_start":1,"highlight_end":62},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// What is the difference between mul & MulAssign?","highlight_start":1,"highlight_end":51},{"text":"// Do we use MulAssign to change the given tuple?","highlight_start":1,"highlight_end":50},{"text":"// And we use MUl if we want to create a new one?","highlight_start":1,"highlight_end":50},{"text":"// Is this the solution that I am looking for?","highlight_start":1,"highlight_end":47},{"text":"// We call self.x etc here because we alter the input tuple.","highlight_start":1,"highlight_end":61},{"text":"// We dont return anything but the tuple.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//impl MulAssign<f64> for Tuple{","highlight_start":1,"highlight_end":33},{"text":"//    fn mul_assign(&mut self, rhs: f64) {","highlight_start":1,"highlight_end":43},{"text":"//        self.x *= rhs;","highlight_start":1,"highlight_end":25},{"text":"//       self.y *= rhs;","highlight_start":1,"highlight_end":24},{"text":"//        self.z *= rhs;","highlight_start":1,"highlight_end":25},{"text":"//        self.w *= rhs;   ","highlight_start":1,"highlight_end":28},{"text":"//    }","highlight_start":1,"highlight_end":8},{"text":"//} ","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl Mul<f64> for Tuple {","highlight_start":1,"highlight_end":26},{"text":"    type Output = Self;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn mul(self, other: f64) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"        Tuple::new(","highlight_start":1,"highlight_end":20},{"text":"            self.x * other,","highlight_start":1,"highlight_end":28},{"text":"            self.y * other,","highlight_start":1,"highlight_end":28},{"text":"            self.z * other,","highlight_start":1,"highlight_end":28},{"text":"            self.w * other ","highlight_start":1,"highlight_end":28},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl Div<f64> for Tuple {","highlight_start":1,"highlight_end":26},{"text":"    type Output = Self;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn div(self, other: f64) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"        Tuple::new(","highlight_start":1,"highlight_end":20},{"text":"            self.x / other,","highlight_start":1,"highlight_end":28},{"text":"            self.y / other,","highlight_start":1,"highlight_end":28},{"text":"            self.z / other,","highlight_start":1,"highlight_end":28},{"text":"            self.w / other","highlight_start":1,"highlight_end":27},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Why the & before self","highlight_start":1,"highlight_end":25},{"text":"// Math operations on Tuples","highlight_start":1,"highlight_end":29},{"text":"impl Tuple{","highlight_start":1,"highlight_end":12},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn magnitude(&self) -> f64{","highlight_start":1,"highlight_end":36},{"text":"        let magnitude_v = f64::sqrt(self.x.powi(2) + self.y.powi(2) + self.z.powi(2) + self.w.powi(2));","highlight_start":1,"highlight_end":104},{"text":"        return magnitude_v;","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn norm(&self) -> Self {","highlight_start":1,"highlight_end":33},{"text":"        *self / self.magnitude()","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Could put everything in one line, dont need the variable. Best practice?","highlight_start":1,"highlight_end":76},{"text":"    pub fn dot(&self, other: Tuple) -> f64{","highlight_start":1,"highlight_end":44},{"text":"        let dot_answer: f64 = (self.x * other.x) +","highlight_start":1,"highlight_end":51},{"text":"                              (self.y * other.y) +","highlight_start":1,"highlight_end":51},{"text":"                              (self.z * other.z) +","highlight_start":1,"highlight_end":51},{"text":"                              (self.w * other.w);","highlight_start":1,"highlight_end":50},{"text":"        return dot_answer; ","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn cross(&self, other: Tuple) -> Tuple{","highlight_start":1,"highlight_end":48},{"text":"        if !self.vector_check() || !other.vector_check() {","highlight_start":1,"highlight_end":59},{"text":"            panic!(\"Can only calculate the cross product of two vectors!\");","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        Tuple::vector ( (self.y * other.z) - (self.z * other.y),","highlight_start":1,"highlight_end":65},{"text":"                        (self.z * other.x) - (self.x * other.z),","highlight_start":1,"highlight_end":65},{"text":"                        (self.x * other.y) - (self.y * other.x),","highlight_start":1,"highlight_end":65},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// WHAT IS THIS","highlight_start":1,"highlight_end":16},{"text":"#[cfg(test)]","highlight_start":1,"highlight_end":13},{"text":"mod tests {","highlight_start":1,"highlight_end":12},{"text":"// use super::*;","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_tuple(x: f64, y:f64, z:f64, w:f64) {","highlight_start":1,"highlight_end":49},{"text":"        let tuple_point = Tuple {x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":58},{"text":"        assert!(tuple_point.x == x);","highlight_start":1,"highlight_end":37},{"text":"        assert!(tuple_point.y == y);","highlight_start":1,"highlight_end":37},{"text":"        assert!(tuple_point.z == z);","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_point(x: f64, y:f64, z: f64) {","highlight_start":1,"highlight_end":43},{"text":"        let test_point = create_point(x, y, z);","highlight_start":1,"highlight_end":48},{"text":"        assert!(test_point.x == x);","highlight_start":1,"highlight_end":36},{"text":"        assert!(test_point.y == y);","highlight_start":1,"highlight_end":36},{"text":"        assert!(test_point.z == z);","highlight_start":1,"highlight_end":36},{"text":"        assert!(test_point.point_check());","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_vector(x: f64, y:f64, z: f64) {","highlight_start":1,"highlight_end":44},{"text":"        let test_vector = create_vector(x, y, z);","highlight_start":1,"highlight_end":50},{"text":"        assert!(test_vector.x == x);","highlight_start":1,"highlight_end":37},{"text":"        assert!(test_vector.y == y);","highlight_start":1,"highlight_end":37},{"text":"        assert!(test_vector.z == z);","highlight_start":1,"highlight_end":37},{"text":"        assert!(test_vector.vector_check());","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_add_tuples(x: f64, y:f64, z: f64, w: f64, a: f64, b: f64, c: f64, v: f64) {","highlight_start":1,"highlight_end":88},{"text":"        let xa = x + a;","highlight_start":1,"highlight_end":24},{"text":"        let yb = y + b;","highlight_start":1,"highlight_end":24},{"text":"        let zc = z + c;","highlight_start":1,"highlight_end":24},{"text":"        let wv = w + v;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let tuple_a = Tuple{x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":53},{"text":"        let tuple_b= Tuple{x: a, y: b, z: c, w: v};","highlight_start":1,"highlight_end":52},{"text":"        let tuple_ab = tuple_a + tuple_b;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(tuple_ab.x == xa);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.y == yb);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.z == zc);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.w == wv);","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_sub_tuples(x: f64, y:f64, z: f64, w: f64, a: f64, b: f64, c: f64, v: f64) {","highlight_start":1,"highlight_end":88},{"text":"        let xa = x - a;","highlight_start":1,"highlight_end":24},{"text":"        let yb = y - b;","highlight_start":1,"highlight_end":24},{"text":"        let zc = z - c;","highlight_start":1,"highlight_end":24},{"text":"        let wv = w - v;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let tuple_a = Tuple{x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":53},{"text":"        let tuple_b= Tuple{x: a, y: b, z: c, w: v};","highlight_start":1,"highlight_end":52},{"text":"        let tuple_ab = tuple_a - tuple_b;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(tuple_ab.x == xa);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.y == yb);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.z == zc);","highlight_start":1,"highlight_end":35},{"text":"        assert!(tuple_ab.w == wv);","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Test operation overload negate.","highlight_start":1,"highlight_end":43},{"text":"        // Here we copy the value of -tuple_a into a new tuple, is this the way to do it?","highlight_start":1,"highlight_end":90},{"text":"        // Seems smart so we use the same adress, otherwise we keep making copies while never using the old stuff.","highlight_start":1,"highlight_end":115},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_negating_tuples(x: f64, y: f64, z: f64, w: f64) {","highlight_start":1,"highlight_end":62},{"text":"        let tuple_a = Tuple{x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":53},{"text":"        let tuple_a_neg = -tuple_a;","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(tuple_a.x == -x);","highlight_start":1,"highlight_end":34},{"text":"        assert!(tuple_a.y == -y);","highlight_start":1,"highlight_end":34},{"text":"        assert!(tuple_a.z == -z);","highlight_start":1,"highlight_end":34},{"text":"        assert!(tuple_a.w == -w);","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let expected_res = Tuple::new(-x, -y, -z, -w);","highlight_start":1,"highlight_end":55},{"text":"        // I can also use this:","highlight_start":1,"highlight_end":32},{"text":"        assert_fuzzy_eq!(tuple_a, expected_res);","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_scalar_tuples(x: f64, y:f64, z: f64, w: f64){","highlight_start":1,"highlight_end":58},{"text":"        let mut tuple_a = Tuple{x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":57},{"text":"        tuple_a *= 3.0;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(tuple_a.x == 3.0 * x);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.y == 3.0 * y);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.z == 3.0 * z);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.w == 3.0 * w);","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_div_tuples(x: f64, y:f64, z: f64, w: f64){","highlight_start":1,"highlight_end":55},{"text":"        let mut tuple_a = Tuple{x: x, y: y, z: z, w: w};","highlight_start":1,"highlight_end":57},{"text":"        tuple_a /= 3.0;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(tuple_a.x == x / 3.0);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.y == y / 3.0);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.z == z / 3.0);","highlight_start":1,"highlight_end":39},{"text":"        assert!(tuple_a.w == w / 3.0);","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_mag_vector(x: f64, y:f64, z: f64){","highlight_start":1,"highlight_end":47},{"text":"        let vector_v = create_vector(x, y, z);","highlight_start":1,"highlight_end":47},{"text":"        let x = f64::powi(x, 2);","highlight_start":1,"highlight_end":33},{"text":"        let y = f64::powi(y, 2);","highlight_start":1,"highlight_end":33},{"text":"        let z = f64::powi(z, 2);","highlight_start":1,"highlight_end":33},{"text":"        let magnitude_v = f64::sqrt(x+y+z);","highlight_start":1,"highlight_end":44},{"text":"        let vector_w = magnitude(vector_v);","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(vector_w == magnitude_v);","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_norm_vector(x: f64, y: f64, z: f64){","highlight_start":1,"highlight_end":49},{"text":"        let tuple_one: Tuple = create_vector(x, y, z);","highlight_start":1,"highlight_end":55},{"text":"        let norm_vec = norm(tuple_one);","highlight_start":1,"highlight_end":40},{"text":"        let norm_x: f64 = x / magnitude(tuple_one);","highlight_start":1,"highlight_end":52},{"text":"        let norm_y: f64 = y / magnitude(tuple_one);","highlight_start":1,"highlight_end":52},{"text":"        let norm_z: f64 = z / magnitude(tuple_one);","highlight_start":1,"highlight_end":52},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        assert!(norm_x == norm_vec.x);","highlight_start":1,"highlight_end":39},{"text":"        assert!(norm_y == norm_vec.y);","highlight_start":1,"highlight_end":39},{"text":"        assert!(norm_z == norm_vec.z);","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vec_two = create_vector(1.0, 2.0, 3.0);","highlight_start":1,"highlight_end":52},{"text":"        let norm_vec_two = norm(vec_two);","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_dot_product(x: f64, y: f64, z: f64, a: f64, b: f64, c: f64){","highlight_start":1,"highlight_end":73},{"text":"        let vec_one = create_vector(x, y, z);","highlight_start":1,"highlight_end":46},{"text":"        let vec_two = create_vector(a, b, c);","highlight_start":1,"highlight_end":46},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"        let dot_answer: f64 = (x * a) + (y * b) + (z * c);","highlight_start":1,"highlight_end":59},{"text":"        let dot_computed: f64 = dot(vec_one, vec_two);","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(dot_answer == dot_computed);","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vec_three = create_vector(1.0, 2.0, 3.0);","highlight_start":1,"highlight_end":54},{"text":"        let vec_four = create_vector(2.0, 3.0, 4.0);","highlight_start":1,"highlight_end":53},{"text":"        let dot_answer = dot(vec_three, vec_four);","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_cross_product(x: f64, y: f64, z: f64, a: f64, b: f64, c: f64){","highlight_start":1,"highlight_end":75},{"text":"        let vec_one = create_vector(x, y, z);","highlight_start":1,"highlight_end":46},{"text":"        let vec_two = create_vector(a, b, c);","highlight_start":1,"highlight_end":46},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let cross_answer_a: f64 = (y * c) - (z * b);","highlight_start":1,"highlight_end":53},{"text":"        let cross_answer_b: f64 = (z * a) - (x * c); ","highlight_start":1,"highlight_end":54},{"text":"        let cross_answer_c: f64 = (x * b) - (y * a);","highlight_start":1,"highlight_end":53},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        let cross_computed: Tuple = cross(vec_one, vec_two);","highlight_start":1,"highlight_end":61},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        assert!(cross_answer_a == cross_computed.x);","highlight_start":1,"highlight_end":53},{"text":"        assert!(cross_answer_b == cross_computed.y);","highlight_start":1,"highlight_end":53},{"text":"        assert!(cross_answer_c == cross_computed.z);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vec_three = create_vector(1.0, 2.0, 3.0);","highlight_start":1,"highlight_end":54},{"text":"        let vec_four = create_vector(2.0, 3.0, 4.0);","highlight_start":1,"highlight_end":53},{"text":"        let cross_answer = cross(vec_three, vec_four);","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn test_flight(x: f64, y: f64, z: f64, a: f64, b: f64, c: f64){","highlight_start":1,"highlight_end":68},{"text":"        let gravity = create_vector(0.0, -0.1, 0.0);","highlight_start":1,"highlight_end":53},{"text":"        let wind = create_vector(-0.01, 0.0, 0.0);","highlight_start":1,"highlight_end":51},{"text":"        let position = create_point(x, y, z);","highlight_start":1,"highlight_end":46},{"text":"        let velocity = create_vector(a, b, c);","highlight_start":1,"highlight_end":47},{"text":"        let mut projectile = Projectile{position: position, velocity: velocity};         ","highlight_start":1,"highlight_end":90},{"text":"        let environment =  Environment{gravity: gravity, wind: wind};","highlight_start":1,"highlight_end":70},{"text":"        //projectiles y","highlight_start":1,"highlight_end":24},{"text":"        let mut n = 0;","highlight_start":1,"highlight_end":23},{"text":"        while projectile.position.y > 0.0 {","highlight_start":1,"highlight_end":44},{"text":"            projectile = tick(environment, projectile);","highlight_start":1,"highlight_end":56},{"text":"            println!(\"Position:, {:?}, Amount of ticks {}\", projectile.position, n);","highlight_start":1,"highlight_end":85},{"text":"            n += 1;","highlight_start":1,"highlight_end":20},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn tick(environment: Environment, mut projectile: Projectile) -> Projectile{","highlight_start":1,"highlight_end":81},{"text":"        let position = add_tuples(projectile.position, projectile.velocity);        ","highlight_start":1,"highlight_end":85},{"text":"        let velocity = add_tuples(projectile.velocity,","highlight_start":1,"highlight_end":55},{"text":"                    add_tuples(environment.gravity, environment.wind));","highlight_start":1,"highlight_end":72},{"text":"        projectile.position = position;","highlight_start":1,"highlight_end":40},{"text":"        projectile.velocity = velocity;","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"consider adding a `main` function to `src\\bin\\tuple.rs`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0601]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `main` function not found in crate `tuple`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\bin\\tuple.rs:2:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m2\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::ops::{Add, Div, Mul, Neg, Sub};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m//use crate::fuzzy_eq::*;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m348\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m349\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider adding a `main` function to `src\\bin\\tuple.rs`\u001b[0m\n\n"}
{"message":"no method named `vector_check` found for reference `&Tuple` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\bin\\tuple.rs","byte_start":3499,"byte_end":3511,"line_start":144,"line_end":144,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"        if !self.vector_check() || !other.vector_check() {","highlight_start":18,"highlight_end":30}],"label":"method not found in `&Tuple`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `vector_check` found for reference `&Tuple` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\bin\\tuple.rs:144:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        if !self.vector_check() || !other.vector_check() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `&Tuple`\u001b[0m\n\n"}
{"message":"no method named `vector_check` found for struct `Tuple` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\bin\\tuple.rs","byte_start":148,"byte_end":164,"line_start":9,"line_end":9,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct Tuple {","highlight_start":1,"highlight_end":17}],"label":"method `vector_check` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\bin\\tuple.rs","byte_start":3524,"byte_end":3536,"line_start":144,"line_end":144,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"        if !self.vector_check() || !other.vector_check() {","highlight_start":43,"highlight_end":55}],"label":"method not found in `Tuple`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `vector_check` found for struct `Tuple` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\bin\\tuple.rs:144:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m9\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mpub struct Tuple {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mmethod `vector_check` not found for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        if !self.vector_check() || !other.vector_check() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `Tuple`\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0599, E0601.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0599, E0601.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0599`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0599`.\u001b[0m\n"}
